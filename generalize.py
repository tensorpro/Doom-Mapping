from __future__ import print_function
from __future__ import absolute_import

from dfp.cfg import EXP_MODE, CFG, VARIABLES, CFG_Base, CFG_Components, FORCE
from dfp.cfg.Experiment import Experiment
import os
import re
import numpy as np
import sys
import pprint
import subprocess as sp

import logging

pp = pprint.PrettyPrinter()

# NOTE: Defining Experiment Types, Important Variables associated with them


class ExpType(object):
    def __init__(self, name, kill_var="USER2", ammo_var="AMMO2",
                 health_var="HEALTH", doom_skill=None):
        self.name = name
        self.kill_var = kill_var
        self.ammo_var = ammo_var
        # I think health var is the only thing that never changes
        self.health_var = health_var
        self.doom_skill = doom_skill


GEN_EXPS = [
    ExpType("simpler_dfp", kill_var="KILLCOUNT", ammo_var="AMMO2"),
    ExpType("defend_the_line", kill_var="KILLCOUNT", ammo_var="AMMO2"),
    ExpType("defend_the_center", kill_var="KILLCOUNT", ammo_var="AMMO2"),
    # NOTE: ammo and kills don't really matter for D1 and D2, but there to make DFP trainable
    ExpType("D1_basic", kill_var="KILLCOUNT", ammo_var="AMMO2"),
    ExpType("D2_navigation", kill_var="KILLCOUNT", ammo_var="AMMO2"),

    ExpType("D3_battle", kill_var="USER2", ammo_var="AMMO2"),
    ExpType("D3_battle_hard", kill_var="USER2", ammo_var="AMMO2"),
    ExpType("D4_battle2", kill_var="USER2", ammo_var="AMMO2")
]

D3_EXPS = [
    ExpType("D3_battle", kill_var="USER2", ammo_var="AMMO2", doom_skill=i)
    for i in range(1, 6)
]

D4_EXPS = [
    ExpType("D4_battle2", kill_var="USER2", ammo_var="AMMO2", doom_skill=i)
    for i in range(1, 6)
]

IMPORTANT_VARS = [
    "screen_resolution",
    "screen_format",
    "render_hud",
    "render_crosshair",
    "render_weapon",
    "render_decals",
    "render_particles",
    "window_visible",
    "doom_skill"
]

IMPORTANT_LISTS = [
    'available_game_variables',
    'available_buttons'
]

LINE_VARS = "%s( *)=( *)([0-9_\+\-\\a-z]+)"
SIMPLE_RE = [re.compile(LINE_VARS % (s), re.IGNORECASE) for s in IMPORTANT_VARS]
LIST_VARS = r"\s*%s\s*=\s*(\{[-a-z0-9_ \n\r\t]*\})"
LIST_RE = [re.compile(LIST_VARS % (s), re.IGNORECASE) for s in IMPORTANT_LISTS]


def _readf(fname):
    f = open(fname, 'r')
    buf = f.read()
    f.close()
    split_buf = buf.split('\n')
    return buf, split_buf


def _parse_vars(split_buf, include_skill=False):
    var_idxs = []
    var_cfg_dict = {}
    # Parse the simple one first
    for line_num, line in enumerate(split_buf):
        for re_id, regexp in enumerate(SIMPLE_RE):
            m = regexp.match(line)

            if m is not None:
                if (not include_skill and
                        line[:len('doom_skill')] == 'doom_skill'):
                    continue
                var_idxs.append(line_num)
                var_cfg_dict[IMPORTANT_VARS[re_id]] = m.group(3)
                break

    return var_cfg_dict, set(var_idxs)


def _parse_lists(buf):
    list_idxs = None
    list_cfg_dict = {}
    for re_id, regexp in enumerate(LIST_RE):
        matches = regexp.finditer(buf)
        for m in matches:
            if IMPORTANT_LISTS[re_id] == 'available_buttons':
                list_cfg_dict[IMPORTANT_LISTS[re_id]] = m.group(1)
            if list_idxs is None:
                list_idxs = np.arange(*m.span())
            else:
                list_idxs = np.concatenate([list_idxs, np.arange(*m.span())], 0)

    if list_idxs is not None:
        return list_cfg_dict, set(list_idxs.tolist())
    else:
        return list_cfg_dict, set()


def _add_cfg(exp):
    if exp[-4:] == '.cfg':
        return exp
    else:
        return exp + '.cfg'


def temp_file(org_cfg_file, target_exp, scenario_dir='./scenarios/', tmp_cfg='tmp.cfg',
              target_skill=None):
    assert isinstance(target_exp, ExpType), "`target_exp` must be a ExpType object"
    # NOTE: Set proper paths for experiments
    target_cfg_file = os.path.join(scenario_dir, _add_cfg(target_exp.name))
    tmp_f = os.path.join(scenario_dir, _add_cfg(tmp_cfg))

    # NOTE: Parse the original file
    buf, split_buf = _readf(org_cfg_file)
    var_cfg_dict, _ = _parse_vars(split_buf, include_skill=target_skill is not None)
    list_cfg_dict, _ = _parse_lists(buf)

    # NOTE: change the target config file
    buf, split_buf = _readf(target_cfg_file)
    # Convert the variables first
    _, rm_var_idx = _parse_vars(split_buf)
    split_buf = [s for i, s in enumerate(split_buf) if i not in rm_var_idx]
    buf = "\n".join(split_buf)

    _, rm_list_idx = _parse_lists(buf)
    buf = "".join([c for i, c in enumerate(buf) if i not in rm_list_idx])

    new_lines = ["\n\n### AUTOGENERATED FROM SCRIPT ###"]
    for k, v in var_cfg_dict.iteritems():
        if target_skill is not None and k.lower() == 'doom_skill':
            new_lines.append("%s = %s" % (k, target_skill))
        else:
            new_lines.append("%s = %s" % (k, v))

    for k, v in list_cfg_dict.iteritems():
        new_lines.append("%s = %s" % (k, v))

    # Lastly, add the variables needed
    new_lines.append("%s = {%s %s %s}" % ('available_game_variables',
                                          target_exp.ammo_var,
                                          target_exp.health_var,
                                          target_exp.kill_var))

    buf = buf + "\n".join(new_lines)
    with open(tmp_f, 'w') as f:
        f.write(buf)
        f.flush()
        f.close()

    return tmp_f


def _call_sp(cmd):
    sp.check_output(cmd.split())


def tex_escape(string):
    for esc in ['_', '^']:
        string = string.replace(esc, '\\' + esc)

    return string


def _fmt_tex(experiment_types, arr1, arr2, fmt, exp_list, label_info):
    n_rows, n_cols = arr1.shape
    assert n_rows == len(experiment_types), "num rows must be experiment types"
    assert n_cols == len(exp_list), "num cols must be experiments ran"

    # NOTE: Tabluate Mean and STDEV
    table_fmt = '|c|' + 'c|' * n_cols
    tex_fmt = "\\begin{table}[!h]\n\\centering\n\\resizebox{\\columnwidth}{!}{%%\n\\begin{tabular}{%s}\n\\hline\n" % (
        table_fmt)
    # Titles

    exp_list = list(map(tex_escape, exp_list))
    tex_fmt += "& " + " & ".join(exp_list) + ' \\\\\n'

    tex_tbl = ""
    for n_row in range(n_rows):
        if experiment_types[n_row].doom_skill is not None:
            exp_name = "%s: %d" % (experiment_types[n_row].name,
                                   experiment_types[n_row].doom_skill)
        else:
            exp_name = experiment_types[n_row].name

        for esc in ['_', '^']:
            exp_name = exp_name.replace(esc, '\\' + esc)

        tex_row = "\\hline\n" + exp_name + " & "
        _row = [fmt for i in range(n_cols)]
        tex_row += " & ".join(_row) + ' \\\\\n'

        tex_tbl += tex_row

    l = np.asarray(zip(arr1.flatten(), arr2.flatten())).flatten().tolist()
    ss = tex_tbl.format(*l)

    tex_fmt += ss + \
        '\\hline\n\\end{tabular}\n}\n\\caption{\\label{tab:table-name}%s}\n\\end{table}\n' % (
            tex_escape(label_info))
    return tex_fmt


def rm_dfp_refs():
    regexp = re.compile('^dfp')
    rm_modules = []
    for k in sys.modules.iterkeys():
        m = regexp.match(k)
        if m is not None:
            rm_modules.append(k)

    for k in rm_modules:
        del sys.modules[k]


def readd_files():
    git_fmt = "git checkout master {0}"
    _call_sp(git_fmt.format('dfp/runner/generalizer.py'))
    _call_sp(git_fmt.format('dfp/agents/multiagent.py'))
    _call_sp(git_fmt.format('dfp/simulator/DoomSimulator.py'))
    _call_sp(git_fmt.format('dfp/cfg/enums.py'))
    _call_sp(git_fmt.format('dfp/cfg/Experiment.py'))
    _call_sp(git_fmt.format('dfp/cfg/__init__.py'))

    _call_sp(git_fmt.format('scenarios/D3_battle_hard.wad'))
    _call_sp(git_fmt.format('scenarios/D3_battle_hard.cfg'))


def run(experiment_types, exp_id, model_dir='./models',
        exp_name='d3_map', tmp_cfg='tmp.cfg',
        use_gpu=False, produce_map=False):
    # NOTE: Must be global, or else variable scope breaks
    global dfp
    global EXP_MODE
    global CFG
    global FORCE
    global VARIABLES
    global CFG_Base
    global CFG_Components
    global Experiment

    chkdir = os.path.join(model_dir, exp_name)
    dirlist = sorted(os.listdir(chkdir))
    available_exp_names = list(map(lambda x: exp_name + '-' + x,
                                   dirlist))

    means = np.zeros((len(experiment_types), len(available_exp_names)))
    stds = np.zeros((len(experiment_types), len(available_exp_names)))
    maxes = np.zeros((len(experiment_types), len(available_exp_names)))
    mins = np.zeros((len(experiment_types), len(available_exp_names)))

    # Evaluate experiments, in order
    for exp_name_id, exp_name in enumerate(available_exp_names):
        for vd_exp_id, vd_exp in enumerate(experiment_types):
            print("Running -- trained on %s, evaluating on %s" % (exp_name,
                                                                  vd_exp.name))

            e = Experiment(mode=EXP_MODE.generalize, exp_name=exp_name, cfg=None,
                           use_gpu=use_gpu, cfg_vision={}, cfg_automap={},
                           cfg_automap_labels={}, debug=True, eval_comp=False)

            # TODO: Change force to default
            if e.load(force=FORCE.ignore_commit):
                rm_dfp_refs()
                readd_files()

                from dfp.cfg import EXP_MODE, CFG, VARIABLES, CFG_Base, CFG_Components, FORCE
                from dfp.cfg.Experiment import Experiment

                e = Experiment(mode=EXP_MODE.generalize, exp_name=exp_name, cfg=None,
                               use_gpu=use_gpu, cfg_vision={}, cfg_automap={},
                               cfg_automap_labels={}, debug=True, eval_comp=False)

                # TODO: Change force to default
                e.load(force=FORCE.ignore_commit)

                cfg = temp_file(e.vd_cfg, vd_exp, tmp_cfg=tmp_cfg,
                                target_skill=vd_exp.doom_skill)

                e.vd_cfg = os.path.join(cfg)

                runner = e.fetch_exp()
                runner = runner(e, produce_map=produce_map)
                if produce_map:
                    rewards, _map = runner.run(5)

                    if not os.path.exists('results/%s' % (exp_id)):
                        os.makedirs('results/%s' % (exp_id))
                    np.save("results/%s/%s.npy" % (exp_id, exp_name), _map)
                    print("exp name", exp_name)
                else:
                    rewards = runner.run(25)

                means[vd_exp_id, exp_name_id] = rewards.mean()
                stds[vd_exp_id, exp_name_id] = rewards.std()
                maxes[vd_exp_id, exp_name_id] = rewards.max()
                mins[vd_exp_id, exp_name_id] = rewards.min()

                # NOTE: Cleanup
                logging.info('Cleaning up experiment')
                _call_sp('git reset --hard')
                _call_sp('git checkout master')

                rm_dfp_refs()
                from dfp.cfg import EXP_MODE, CFG, VARIABLES, CFG_Base, CFG_Components, FORCE
                from dfp.cfg.Experiment import Experiment
            else:
                logging.warn('skipping %s, does not exist' % (exp_name))

    # NOTE: Latex Table Output
    if not os.path.exists('results/%s' % (exp_name)):
        os.makedirs('results/%s' % (exp_name))

    tex = _fmt_tex(experiment_types, means, stds,
                   "${:2.2f}\\pm {:2.2f}$", dirlist, "%s Reward MEAN and STD" % (exp_name))
    tex += "\n" + _fmt_tex(experiment_types, mins, maxes,
                           "$[{:2.2f},{:2.2f}]$", dirlist, "%s Reward MINS and MAX" % (exp_name))
    return tex


def main(exp, to_run, use_gpu=False, produce_map=False):
    tex = "\\section{%s Results}\n" % (tex_escape(exp))
    for exps, exps_id in to_run:
        tex += '\\subsection{%s}\n' % (exps_id) + \
               run(exps, exps_id, exp_name=exp,
                   use_gpu=use_gpu, produce_map=produce_map) + '\n'

    with open('results/%s.tex' % (exp), 'w') as f:
        f.write(tex)
        f.flush()
        f.close()


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('-g', '--use-gpu', action='store_true',
                        help='use the GPU when evaluating')
    parser.add_argument('-e', '--experiment', type=str, required=True,
                        help="Specify which models folder to evaluate to evaluate on")
    args = parser.parse_args()
    # to_run = [
    #     (GEN_EXPS, 'Generalization'),
    #     (D3_EXPS, 'D3 Various Difficulties'),
    #     (D4_EXPS, 'D4 Various Difficulties')
    # ]

    # main(args.experiment, to_run, use_gpu=args.use_gpu)

    exp_prefix = args.experiment[:2]

    if exp_prefix == 'd3':
        to_run = [
            ([ExpType("D3_battle", kill_var="USER2", ammo_var="AMMO2")],
             "D3 Coverage")
        ]
        main(args.experiment, to_run, use_gpu=args.use_gpu, produce_map=True)
    elif exp_prefix == 'd4':
        to_run = [
            ([ExpType("D4_battle2", kill_var="USER2", ammo_var="AMMO2")],
             "D4 Coverage")
        ]
        main(args.experiment, to_run, use_gpu=args.use_gpu, produce_map=True)

    # main(D3_EXPS, 'd3_diffs', exp_name=args.experiment, use_gpu=args.use_gpu)
    # main(D4_EXPS, 'd4_diffs', exp_name=args.experiment, use_gpu=args.use_gpu)

    # main(GEN_EXPS, 'generalize', exp_name='d7', use_gpu=False)
    # main(D3_EXPS, 'd3_diffs', exp_name='d7', use_gpu=False)
    # main(D4_EXPS, 'd4_diffs', exp_name='d7', use_gpu=False)
